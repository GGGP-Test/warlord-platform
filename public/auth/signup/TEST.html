<!DOCTYPE html>
<html lang="en" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sign Up - MyWebApp</title>
    
    <!-- Firebase Configuration -->
    <script>
        window.__FIREBASE_CONFIG__ = {
            apiKey: "AIzaSyDk7vVnSiMfYJPJ38gbw21fzqsBTu1PbC8",
            authDomain: "warlord-1cbe3.firebaseapp.com",
            projectId: "warlord-1cbe3",
            storageBucket: "warlord-1cbe3.firebasestorage.app",
            messagingSenderId: "212906032385",
            appId: "1:212906032385:web:441058c2ed0c88ace16f00"
        };
    </script>
    
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
    
    <!-- Google Identity Services -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    
    <!-- Plus Jakarta Sans for headings + Inter for body text -->
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@600;700;800&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* ... (keeping all existing styles) ... */
        /* (I'll keep the full styles but omitting here for brevity - they stay the same) */
        
        /* NEW: Verification Panel Styles */
        .verification-panel {
            width: 100%;
            max-width: 420px;
            margin: 1rem auto 0;
            padding: 1rem 1.25rem;
            border-radius: 14px;
            background: linear-gradient(135deg, 
                rgba(34, 197, 94, 0.08) 0%,
                rgba(34, 197, 94, 0.04) 100%);
            border: 1px solid rgba(34, 197, 94, 0.2);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.08);
            opacity: 0;
            transform: translateY(-8px);
            transition: opacity 0.35s cubic-bezier(0.34, 1.56, 0.64, 1),
                       transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .verification-panel.show {
            opacity: 1;
            transform: translateY(0);
        }

        .verification-panel-text {
            font-size: 13px;
            line-height: 1.6;
            color: var(--foreground);
            margin-bottom: 0.75rem;
        }

        .verification-panel-email {
            font-weight: 700;
            color: var(--foreground);
        }

        .verification-panel-actions {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            font-size: 12px;
        }

        .verification-panel-link {
            color: var(--primary);
            text-decoration: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .verification-panel-link:hover {
            color: var(--foreground);
            text-decoration: underline;
        }

        .verification-panel-divider {
            color: var(--muted-foreground);
        }

        /* Login Link Styles */
        .login-link-container {
            margin-top: 1.5rem;
            text-align: center;
            font-size: 13px;
            color: var(--muted-foreground);
        }

        .login-link {
            color: var(--primary);
            text-decoration: none;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .login-link:hover {
            color: var(--foreground);
            text-decoration: underline;
        }

        /* Keep all existing styles from original file */
        @keyframes badgeSlideIn {
            from { opacity: 0; transform: translateY(-8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* ... (all other existing styles remain the same) ... */
    </style>
    <!-- Note: In actual implementation, include ALL original styles here -->
</head>
<body class="min-h-screen flex items-center justify-center relative overflow-hidden">
    <!-- Keep existing topbar -->
    <!-- ... -->

    <!-- Sign Up Content -->
    <div class="relative z-10 w-full max-w-sm mx-2 flex flex-col items-center content-container">
        <h1 class="heading-custom font-bold text-foreground text-center tracking-tighter mb-2 animate-entrance-heading" id="main-heading">
            Get started with Us
        </h1>
        <p class="text-sm text-muted-foreground text-center subtitle-tight animate-entrance-description" id="subtitle">Continue with</p>

        <!-- Verification Panel (hidden by default) -->
        <div class="verification-panel" id="verification-panel" style="display: none;">
            <div class="verification-panel-text">
                We sent a verification link to <span class="verification-panel-email" id="verify-email">‚Äî</span>. 
                Open it on this device to verify, then return to <a href="/auth/login/" class="verification-panel-link" id="login-from-verify">log in</a>.
            </div>
            <div class="verification-panel-actions">
                <a class="verification-panel-link" id="resend-link">Resend</a>
                <span class="verification-panel-divider">¬∑</span>
                <a class="verification-panel-link" id="change-email-link">Use a different email</a>
            </div>
        </div>

        <!-- Form Content (keep existing structure) -->
        <form class="w-[300px] space-y-6" id="signup-form">
            <!-- ... keep all existing form fields ... -->

            <!-- NEW: Login Link at Bottom -->
            <div class="login-link-container animate-entrance-terms" id="login-link-container">
                Already have an account? <a href="/auth/login/" class="login-link" id="login-link">Log in</a>
            </div>
        </form>
    </div>

    <script>
        // Initialize Firebase
        firebase.initializeApp(window.__FIREBASE_CONFIG__);
        const auth = firebase.auth();
        const db = firebase.firestore();

        const PERSONAL_DOMAINS = new Set([
            'gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com', 
            'aol.com', 'icloud.com', 'mail.com', 'protonmail.com',
            'yandex.com', 'zoho.com', 'gmx.com', 'inbox.com',
            'googlemail.com', 'ymail.com', 'live.com', 'msn.com',
            'me.com', 'mac.com', 'pm.me', 'fastmail.com', 'hey.com'
        ]);

        const EMAIL_KEY = 'gg_pending_email';
        const VERIFIED_KEY = 'gg_email_verified';

        // Helper functions
        function extractDomain(email) {
            const match = email.match(/@([^@\\s]+)$/);
            return match ? match[1].toLowerCase() : null;
        }

        function isBusinessEmail(email) {
            const domain = extractDomain(email);
            return domain && !PERSONAL_DOMAINS.has(domain);
        }

        // Domain claim system (Firestore)
        async function checkDomainClaim(domain, email) {
            if (!db || !domain) return { state: 'unknown' };
            try {
                const snap = await db.collection('domainClaims').doc(domain).get();
                if (!snap.exists) return { state: 'free' };
                
                const data = snap.data() || {};
                const owner = (data.owner || data.claimedBy || '').toLowerCase();
                const status = String(data.status || 'verified').toLowerCase();
                const isSelf = owner && owner === (email || '').toLowerCase();
                
                if (status === 'verified') {
                    return { state: isSelf ? 'claimed-verified-self' : 'claimed-verified-other', data };
                }
                return { state: isSelf ? 'pending-self' : 'pending-other', data };
            } catch (e) {
                console.error('Domain check error:', e);
                return { state: 'unavailable' };
            }
        }

        async function claimDomain(domain, email, uid, status = 'pending') {
            if (!db || !domain) return { ok: true, skip: true };
            try {
                const res = await db.runTransaction(async (tx) => {
                    const ref = db.collection('domainClaims').doc(domain);
                    const snap = await tx.get(ref);
                    
                    if (snap.exists) {
                        const data = snap.data() || {};
                        const owner = (data.owner || data.claimedBy || '').toLowerCase();
                        if (owner && owner !== (email || '').toLowerCase()) {
                            return { ok: false, reason: 'claimed-other', data };
                        }
                        // Same owner - upgrade status if needed
                        const next = Object.assign({}, data);
                        next.owner = email;
                        if (uid) next.uid = uid;
                        if ((next.status || 'pending').toLowerCase() !== 'verified' && status === 'verified') {
                            next.status = 'verified';
                            next.verifiedAt = firebase.firestore.FieldValue.serverTimestamp();
                        } else if (!next.status) {
                            next.status = status;
                        }
                        tx.set(ref, next, { merge: true });
                        return { ok: true, already: true, data: next };
                    }
                    
                    tx.set(ref, {
                        owner: email,
                        uid: uid || null,
                        status: status,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        verifiedAt: status === 'verified' ? firebase.firestore.FieldValue.serverTimestamp() : null
                    });
                    return { ok: true, claimed: true, status: status };
                });
                return res;
            } catch (e) {
                console.error('Domain claim error:', e);
                return { ok: false, reason: 'registry-unavailable' };
            }
        }

        async function finalizeClaim(domain, email) {
            if (!db || !domain) return;
            try {
                await db.runTransaction(async (tx) => {
                    const ref = db.collection('domainClaims').doc(domain);
                    const snap = await tx.get(ref);
                    
                    if (!snap.exists) {
                        tx.set(ref, {
                            owner: email,
                            uid: auth?.currentUser?.uid || null,
                            status: 'verified',
                            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                            verifiedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        return;
                    }
                    
                    const data = snap.data() || {};
                    const owner = (data.owner || data.claimedBy || '').toLowerCase();
                    if (owner && owner !== (email || '').toLowerCase()) return;
                    
                    tx.set(ref, {
                        owner: email,
                        uid: auth?.currentUser?.uid || data.uid || null,
                        status: 'verified',
                        verifiedAt: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                });
            } catch (e) {
                console.error('Finalize claim error:', e);
            }
        }

        async function sendVerificationEmail() {
            if (!auth?.currentUser) throw new Error('no_user');
            try { auth.useDeviceLanguage(); } catch (_) {}
            
            const url = new URL('/auth/bridge/', location.origin);
            await auth.currentUser.sendEmailVerification({ 
                url: url.href, 
                handleCodeInApp: false 
            });
            
            try { localStorage.setItem(EMAIL_KEY, auth.currentUser.email || ''); } catch (_) {}
            return true;
        }

        // Verification panel handlers
        const verificationPanel = document.getElementById('verification-panel');
        const verifyEmail = document.getElementById('verify-email');
        const resendLink = document.getElementById('resend-link');
        const changeEmailLink = document.getElementById('change-email-link');
        const loginFromVerify = document.getElementById('login-from-verify');

        function showVerificationPanel(email) {
            verifyEmail.textContent = email;
            verificationPanel.style.display = 'block';
            setTimeout(() => verificationPanel.classList.add('show'), 50);
            
            // Update login link with email
            const loginLink = document.getElementById('login-link');
            if (loginLink) {
                loginLink.href = `/auth/login/?email=${encodeURIComponent(email)}`;
            }
            if (loginFromVerify) {
                loginFromVerify.href = `/auth/login/?email=${encodeURIComponent(email)}`;
            }
        }

        function hideVerificationPanel() {
            verificationPanel.classList.remove('show');
            setTimeout(() => verificationPanel.style.display = 'none', 350);
        }

        resendLink?.addEventListener('click', async (e) => {
            e.preventDefault();
            if (!auth.currentUser) {
                showError('confirm-password-error', '‚ùå No user session. Please sign up again.');
                return;
            }
            
            try {
                await sendVerificationEmail();
                resendLink.textContent = 'Sent!';
                setTimeout(() => resendLink.textContent = 'Resend', 2000);
            } catch (error) {
                console.error('Resend error:', error);
                showError('confirm-password-error', '‚ùå Failed to resend. Try again later.');
            }
        });

        changeEmailLink?.addEventListener('click', (e) => {
            e.preventDefault();
            hideVerificationPanel();
            location.reload();
        });

        // Update login link dynamically
        function updateLoginLink(email) {
            const loginLink = document.getElementById('login-link');
            if (loginLink && email && /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email)) {
                loginLink.href = `/auth/login/?email=${encodeURIComponent(email)}`;
            } else if (loginLink) {
                loginLink.href = '/auth/login/';
            }
        }

        // Email input listener for login link
        const emailInput = document.getElementById('email-input');
        emailInput?.addEventListener('input', () => {
            updateLoginLink(emailInput.value.trim());
        });
        emailInput?.addEventListener('blur', () => {
            updateLoginLink(emailInput.value.trim());
        });

        // Modified confirmPasswordNextBtn click handler
        const originalConfirmHandler = document.getElementById('confirm-password-next-btn');
        originalConfirmHandler?.addEventListener('click', async function(e) {
            e.preventDefault();
            
            const emailVal = emailInput.value.trim();
            const password = document.getElementById('password-input').value;
            const confirmPassword = document.getElementById('confirm-password-input').value;
            
            if (password !== confirmPassword) {
                showError('confirm-password-error', '‚ùå Passwords do not match');
                return;
            }
            
            if (!isBusinessEmail(emailVal)) {
                showError('confirm-password-error', 'üö´ Please use a business email. Personal emails are not allowed.');
                return;
            }
            
            const btn = this;
            setButtonLoading(btn, true);
            hideError('confirm-password-error');
            
            try {
                const domain = extractDomain(emailVal);
                
                // Check domain claim
                const domainCheck = await checkDomainClaim(domain, emailVal);
                if (domainCheck.state === 'claimed-verified-other') {
                    setButtonLoading(btn, false);
                    showError('confirm-password-error', '‚ùå Company already registered. <a href="/auth/login/?email=' + encodeURIComponent(emailVal) + '" style="color: #fff; text-decoration: underline;">Log in</a>');
                    return;
                }
                
                // Create user
                const userCredential = await auth.createUserWithEmailAndPassword(emailVal, password);
                const user = userCredential.user;
                
                // Create PENDING domain claim
                const claim = await claimDomain(domain, emailVal, user.uid, 'pending');
                if (!claim.ok && claim.reason === 'claimed-other') {
                    await auth.currentUser?.delete();
                    await auth.signOut();
                    setButtonLoading(btn, false);
                    showError('confirm-password-error', '‚ùå Company already registered. <a href="/auth/login/?email=' + encodeURIComponent(emailVal) + '" style="color: #fff; text-decoration: underline;">Log in</a>');
                    return;
                }
                
                // Send verification email
                await sendVerificationEmail();
                
                // Show verification panel
                hideError('confirm-password-error');
                document.getElementById('confirm-password-container').classList.remove('show');
                document.getElementById('confirm-password-go-back').classList.remove('show');
                showVerificationPanel(emailVal);
                
                setButtonLoading(btn, false);
                
            } catch (error) {
                console.error('Signup error:', error);
                setButtonLoading(btn, false);
                
                if (error.code === 'auth/email-already-in-use') {
                    showError('confirm-password-error', '‚ùå This email is already registered. <a href="/auth/login/?email=' + encodeURIComponent(emailVal) + '" style="color: #fff; text-decoration: underline;">Log in</a>');
                } else if (error.code === 'auth/weak-password') {
                    showError('confirm-password-error', '‚ùå Password is too weak');
                } else {
                    showError('confirm-password-error', '‚ùå An error occurred. Please try again.');
                }
            }
        });

        // Google Sign-In with domain claiming
        document.getElementById('google-login')?.addEventListener('click', async function() {
            const btn = this;
            setButtonLoading(btn, true);
            hideError('email-error');

            try {
                const provider = new firebase.auth.GoogleAuthProvider();
                provider.setCustomParameters({ prompt: 'select_account' });

                const result = await auth.signInWithPopup(provider);
                const user = result.user;
                const email = user.email;
                const domain = extractDomain(email);
                const isNew = result?.additionalUserInfo?.isNewUser === true;

                if (!isBusinessEmail(email)) {
                    await auth.signOut();
                    showError('email-error', 'üö´ Please use your business email. Personal emails (Gmail, Yahoo, etc.) are not allowed.');
                    setButtonLoading(btn, false);
                    return;
                }
                
                if (!isNew) {
                    await auth.signOut();
                    showError('email-error', '‚ùå Account exists. <a href="/auth/login/?email=' + encodeURIComponent(email) + '" style="color: #fff; text-decoration: underline;">Log in</a>');
                    setButtonLoading(btn, false);
                    return;
                }

                // Google identity is verified - create VERIFIED claim
                const claim = await claimDomain(domain, email, user.uid, 'verified');
                if (!claim.ok) {
                    await auth.currentUser?.delete();
                    await auth.signOut();
                    if (claim.reason === 'claimed-other') {
                        showError('email-error', '‚ùå Company already registered. <a href="/auth/login/?email=' + encodeURIComponent(email) + '" style="color: #fff; text-decoration: underline;">Log in</a>');
                    } else {
                        showError('email-error', '‚ùå Unable to verify company. Try again later.');
                    }
                    setButtonLoading(btn, false);
                    return;
                }

                // Success - redirect to verified page
                window.location.href = '/auth/verified';
                
            } catch (error) {
                console.error('Google sign-in error:', error);
                setButtonLoading(btn, false);
                
                if (error.code === 'auth/popup-closed-by-user') {
                    showError('email-error', 'Sign-in cancelled. Please try again.');
                } else if (error.code === 'auth/popup-blocked') {
                    showError('email-error', 'Pop-up blocked. Please allow pop-ups and try again.');
                } else {
                    showError('email-error', 'An error occurred. Please try again.');
                }
            }
        });

        // Handle email verification callback (when user clicks link in email)
        async function handleVerifyOnLoad() {
            if (!auth) return;
            const p = new URLSearchParams(location.search);
            const mode = p.get('mode');
            const oob = p.get('oobCode');
            
            if (mode === 'verifyEmail' && oob) {
                try {
                    await auth.applyActionCode(oob);
                    await auth.currentUser?.reload();
                    history.replaceState({}, '', location.pathname);
                    sessionStorage.setItem(VERIFIED_KEY, '1');
                    
                    const em = localStorage.getItem(EMAIL_KEY) || auth.currentUser?.email || '';
                    const domain = extractDomain(em);
                    
                    // Finalize domain claim
                    await finalizeClaim(domain, em);
                    
                    // Redirect to bridge/verified page
                    window.location.href = '/auth/bridge/';
                } catch (e) {
                    console.error('Verification error:', e);
                    showError('email-error', '‚ùå Verification link invalid or expired. Request a new one.');
                }
            }
        }
        handleVerifyOnLoad();

        // Keep all existing form logic (step transitions, validation, etc.)
        // ... (existing JavaScript continues here) ...
    </script>
</body>
</html>